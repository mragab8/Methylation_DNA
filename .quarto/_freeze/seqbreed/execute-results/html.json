{
  "hash": "0a33969eebb661a3935b1fff02c41f51",
  "result": {
    "markdown": "---\nexecute: \n  warning: false\n  message: false\nbibliography: references.bib\n---\n\n\n## Precisión de la predición mediante simulación con SeqBreed {.unnumbered}\n\nHoy en día, los métodos de predicción genómica se usan ampliamente en la mejora genética de plantas y de animales. Antes de que estos métodos sean implementados en escenarios prácticos, es importante conocer su precisión al predecir el valor de cría estimado (EBV, o GEBV al realizar la predicción utilizando SNP). En este sentido, uno de los objetivos de mi trabajo de grado consistió en estudiar el efecto del número de marcadores (SNP) sobre la precisión del GEBV para el carácter tiempo de floración en el arroz. Para ello, se realizó un estudio de simulación a partir del uso del módulo `SeqBreed` [@pérez-enciso2020] del lenguaje de programación `Python`[@Python].\n\nCada uno de los pasos llevados a cabo en dicho estudio de simulación los describiré a continuación (@fig-seqbreed).\n\n\n::: {.cell}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Esquema de predicción usando simulación con el paquete SeqBreed.](seqbreed_files/figure-html/fig-seqbreed-1.png){#fig-seqbreed fig-align='center' width=74%}\n:::\n:::\n\n\n### 1. Uso de genotipos de la población fundadora\n\nPara simular los datos de fenotipo y de genotipo se usaron los datos con los 100.231 SNP resultantes del control de calidad y que puede descargar en el capítulo donde se describen los datos. Luego, usando las funciones `gg.GFounder()` y `gg.Genome()`, como se puede observar en el código a continuación, se obtuvo un archivo que indicó el número de individuos genotipados o individuos de la población fundadora (451), la ploidía (2) y el número de SNP (100.231).\n\n\n::: {.cell}\n\n```{.python .cell-code}\nSNP_pos = 'SNP_pos'\n\nGen_Pob_base = gg.GFounder(vcfFile = vcf_IND, snpFile = SNP_pos)\n```\n:::\n\n\n::: codigo\nCon el argumento `vcfFile` de la función `gg.GFounder()`, se carga los genotipos de la llamada población fundadora en formato variant call. Con esta función se obtiene la posición de cada uno de los SNP, y esta a su vez se almacena en el objeto SNP_pos previamente definido.\n:::\n\n\n::: {.cell}\n\n```{.python .cell-code}\nGen_caracteristicas = gg.Genome(snpFile = SNPs_pos, mapFile = None, ploidy = Gen_Pob_base.ploidy,  XChr = 'X', YChr = 'Y', MTChr = 'MT')\n```\n:::\n\n\n::: codigo\nCon la función `gg.Genome()` se genera un objeto de clase `Genome` con algunas de las características del genoma de la población fundadora, como son el nombre y el número de cromosomas. Con el argumento `snpFile` se especifica el objeto SNP_pos generado en el paso anterior, además de que si se dispone del nombre de los cromosomas sexuales y mitocondrial, estos se especifican en los argumentos `XChr`, `YChr` y `MT`. Aquí, no se dispuso de un archivo con información acerca de recombinación genética y mapeo de genes, por lo cual en el argumento `mapFile` se colocó \"None\".\n:::\n\n### 2. Especificación de la arquitectura genética (SNP causales (QTN) y sus efectos)\n\nSe llevo a cabo inicialmente un estudio de asociación a nivel genómico (GWAS) usando el software `GCTA`[@yang2011], para identificar las regiones genómicas asociadas con el carácter tiempo de floración. A continuación podrá descargar el archivo que resultó al hacer el GWAS, donde se específica el efecto de los QTN y su localización.\n\n::: {.callout appearance=\"minimal\"}\n<i class=\"bi bi-download\"></i> [Datos GWAS](datos/gwas.mlma){download=\"gwas.mlma\"}\n:::\n\nPosteriomente, con base en el GWAS (@fig-GWAS), se seleccionaron 50 QTN cuyo efecto era proporcional a la varianza aditiva explicada.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Visualización del GWAS para el carácter tiempo de floración en el arroz.](seqbreed_files/figure-html/fig-GWAS-1.png){#fig-GWAS fig-align='center' width=74%}\n:::\n:::\n\n\nA continuación podrá descargar los 50 QTN seleccionados.\n\n::: {.callout appearance=\"minimal\"}\n<i class=\"bi bi-download\"></i> [Datos QTN](datos/QTN.txt){download=\"QTN.txt\"}\n:::\n\nPor último, se usó la función `gg.QTNs()` sobre estos datos generados, indicando también la heredabilidad del carácter (0.7) de acuerdo a resultados previamente reportados [@Vourlakietal].\n\n\n::: {.cell}\n\n```{.python .cell-code}\nQTN = 'QTN.txt'\n\nQTNs = gg.QTNs(h2 = [0.7], genome = Gen_caracteristicas, qtnFile = QTN)\n```\n:::\n\n\n::: codigo\nCon la función `gg.QTNs()` se determina la arquitectura genética para el carácter simulado. Para ello, se especifica un valor deseado de heredabilidad con el argumento `h2`, se carga el archivo QTN.txt que indica el efecto y la localización de cada uno de los QTN seleccionados anteriormente con el argumento `qtnFile`, y con el argumento `genome` se accede a las características del genoma previamente almacenado.\n:::\n\n### 3. Generación de pedigríes\n\nInicialmente, se generaron cuatro pedigríes, cada uno de ellos con esquemas de cruzamiento diferentes partiendo de la población fundadora con 451 individuos.\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div id=\"ootehenush\" style=\"overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>html {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n}\n\n#ootehenush .gt_table {\n  display: table;\n  border-collapse: collapse;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#ootehenush .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#ootehenush .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#ootehenush .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 0;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#ootehenush .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#ootehenush .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#ootehenush .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#ootehenush .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#ootehenush .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#ootehenush .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#ootehenush .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#ootehenush .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#ootehenush .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#ootehenush .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#ootehenush .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#ootehenush .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#ootehenush .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ootehenush .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#ootehenush .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#ootehenush .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ootehenush .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#ootehenush .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#ootehenush .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#ootehenush .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ootehenush .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#ootehenush .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#ootehenush .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#ootehenush .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#ootehenush .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-left: 4px;\n  padding-right: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ootehenush .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#ootehenush .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ootehenush .gt_left {\n  text-align: left;\n}\n\n#ootehenush .gt_center {\n  text-align: center;\n}\n\n#ootehenush .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#ootehenush .gt_font_normal {\n  font-weight: normal;\n}\n\n#ootehenush .gt_font_bold {\n  font-weight: bold;\n}\n\n#ootehenush .gt_font_italic {\n  font-style: italic;\n}\n\n#ootehenush .gt_super {\n  font-size: 65%;\n}\n\n#ootehenush .gt_two_val_uncert {\n  display: inline-block;\n  line-height: 1em;\n  text-align: right;\n  font-size: 60%;\n  vertical-align: -0.25em;\n  margin-left: 0.1em;\n}\n\n#ootehenush .gt_footnote_marks {\n  font-style: italic;\n  font-weight: normal;\n  font-size: 75%;\n  vertical-align: 0.4em;\n}\n\n#ootehenush .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#ootehenush .gt_slash_mark {\n  font-size: 0.7em;\n  line-height: 0.7em;\n  vertical-align: 0.15em;\n}\n\n#ootehenush .gt_fraction_numerator {\n  font-size: 0.6em;\n  line-height: 0.6em;\n  vertical-align: 0.45em;\n}\n\n#ootehenush .gt_fraction_denominator {\n  font-size: 0.6em;\n  line-height: 0.6em;\n  vertical-align: -0.05em;\n}\n</style>\n<table class=\"gt_table\">\n  \n  <thead class=\"gt_col_headings\">\n    <tr>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\"> </th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\">Pedigrí 1</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\">Pedigri 2</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\">Pedigrí 3</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\">Pedigrí 4</th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td class=\"gt_row gt_left\">F0</td>\n<td class=\"gt_row gt_left\">451</td>\n<td class=\"gt_row gt_left\">451</td>\n<td class=\"gt_row gt_left\">451</td>\n<td class=\"gt_row gt_left\">451</td></tr>\n    <tr><td class=\"gt_row gt_left\">F1</td>\n<td class=\"gt_row gt_left\">10<sup class=\"gt_footnote_marks\">1</sup></td>\n<td class=\"gt_row gt_left\">20</td>\n<td class=\"gt_row gt_left\">40</td>\n<td class=\"gt_row gt_left\">80</td></tr>\n    <tr><td class=\"gt_row gt_left\">F2</td>\n<td class=\"gt_row gt_left\">800 (10x80)<sup class=\"gt_footnote_marks\">2</sup></td>\n<td class=\"gt_row gt_left\">800 (20x40)</td>\n<td class=\"gt_row gt_left\">800 (40x20)</td>\n<td class=\"gt_row gt_left\">800 (80x10)</td></tr>\n    <tr><td class=\"gt_row gt_left\">F3</td>\n<td class=\"gt_row gt_left\">800 (800x1)<sup class=\"gt_footnote_marks\">3</sup></td>\n<td class=\"gt_row gt_left\">800 (800x1)</td>\n<td class=\"gt_row gt_left\">800 (800x1)</td>\n<td class=\"gt_row gt_left\">800 (800x1)</td></tr>\n    <tr><td class=\"gt_row gt_left\">Total</td>\n<td class=\"gt_row gt_left\">2.061</td>\n<td class=\"gt_row gt_left\">2.071</td>\n<td class=\"gt_row gt_left\">2.091</td>\n<td class=\"gt_row gt_left\">2.131</td></tr>\n  </tbody>\n  \n  <tfoot class=\"gt_footnotes\">\n    <tr>\n      <td class=\"gt_footnote\" colspan=\"5\"><sup class=\"gt_footnote_marks\">1</sup> 10 indica el número de descendientes que tendrían los 451 individuos de la generación F0 mediante cruzamiento.</td>\n    </tr>\n    <tr>\n      <td class=\"gt_footnote\" colspan=\"5\"><sup class=\"gt_footnote_marks\">2</sup> 10x80 indica el número de descendientes (80) que tendrían cada uno de los 10 individuos de la generación F1 por autofecundación, dando un total de 800 individuos en la generación F2.</td>\n    </tr>\n    <tr>\n      <td class=\"gt_footnote\" colspan=\"5\"><sup class=\"gt_footnote_marks\">3</sup> 800x1 indica el número de descendientes (1) que tendrían cada uno de los 800 individuos de la generación F2 por autofecundación, dando un total de 800 individuos en la generación F3.</td>\n    </tr>\n  </tfoot>\n</table>\n</div>\n```\n:::\n:::\n\n\nA continuación podrá descargar los cuatro pedigríes generados.\n\n::: {.callout appearance=\"minimal\"}\n<i class=\"bi bi-download\"></i> [Pedigrí 1](datos/Pedigri_1.txt){download=\"Pedigri_1.txt\"}   [Pedigrí 2](datos/Pedigri_2.txt){download=\"Pedigri_2.txt\"}   [Pedigrí 3](datos/Pedigri_3.txt){download=\"Pedigri_3.txt\"}   [Pedigrí 4](datos/Pedigri_4.txt){download=\"Pedigri_4.txt\"}\n:::\n\nPosteriormente, se generó mediante simulación utilizando la función `gg.Population()`, los fenotipos y genotipos de cada uno de los individuos de los cuatro pedigríes anteriores.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nPedigri_1 = 'Pedigri_1.txt'\n\nPob_1 = gg.Population(Gen_caracteristicas, pedFile = Pedigri_1, generation = None, qtns = QTNs, gfounders = Gen_Pob_base)\n```\n:::\n\n\n::: codigo\nPara simular los fenotipos y genotipos a partir de la función `gg.Population()`, se especifica en el argumento `pedFile` el pedigrí con los individuos a los cuales dicha información se simulará. Como puede observar, algunos de los objetos generados en pasos anteriores (las características del genoma y los genotipos de la población fundadora), se especifican también aquí.\n:::\n\n::: aclaracion\nEl módulo de `Python` `SeqBreed`, simula los fenotipos ($y_{i}$) de cada uno de los individuos del pedigrí proporcionado con base en la expresión $y_{i} = \\mu + g_{i} + e_{i}$, donde $\\mu$ es la media, $g_{i}$ es el genotipo del individuo, y $e_{i}$ es el error.\n:::\n\n### 4. Uso de subconjuntos de datos con diferentes densidades de SNP\n\nDel conjunto de datos total con 100.231 SNP luego del control de calidad, se seleccionaron de forma aleatoria mediante el uso de Plink [@purcell2007], tres subconjuntos de datos de SNP de manera que el número de marcadores aproximado fuera igual a 1.000, 10.000 y 100.000 SNP. A continuación podrá descargar los subconjuntos de datos de SNP.\n\n::: {.callout appearance=\"minimal\"}\n<i class=\"bi bi-download\"></i> [Chip 1](datos/chip_1.txt){download=\"chip_1.txt\"}   [Chip 2](datos/chip_2.txt){download=\"chip_2.txt\"}   [Chip 3](datos/chip_3.txt){download=\"chip_3.txt\"}\n:::\n\n\n::: {.cell}\n\n```{.python .cell-code}\nden_chips = ['/chip_1.txt', '/chip_2.txt', '/chip_3.txt', SNP_pos]\n\nchips = []\nfor file in den_chips:\n    chip = gg.Chip(chipFile = file, genome = Gen_caracteristicas, name = file + '_chip')\n    chips.append(chip)\n```\n:::\n\n\n::: codigo\nPara generar el objeto chip, ya que este variara en los análisis que se presentaran a continuación de acuerdo a distintas densidades aproximadas de marcadores (1.000, 10.000 y 100.000), inicialmente se crea una lista con los distintos subconjuntos de datos de SNP que puede descargar en la instrucción anterior a este código. Luego, se genera el objeto chip a través de un bucle `for`.\n:::\n\n### 5. Implementación de los métodos BLUP y ssGBLUP\n\nSe usó la función `sel.doEbv()` para llevar a cabo la predicción, usando los modelos BLUP y ssGBLUP descritos anteriormente en el capítulo sobre Modelos de predicción. A continuación podrá observar todo el código que se utilizó.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nind_gen = np.arange(2061, dtype = np.int)\n\nind_fen = np.arange(461, dtype = np.int)\n\nitrait = 0\n```\n:::\n\n\n::: codigo\nSe crean los objetos ind_gen e ind_fen, en los cuales se indica que individuos están genotipados (del individuo 1 al 2061 en el pedigrí 1) y fenotipados (los primeros 461 individuos, que corresponden a los individuos de las generaciones $F_{0}$ y $F_{1}$, ya que los individuos de las generaciones $F_{2}$ y $F_{3}$ corresponde a la muestra de validación).\n:::\n\n#### 5.1. Método BLUP\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsel.doEbv(Pob_1, criterion = 'blup', yIds = ind_fen, h2 = 0.7, itrait = itrait)\n\nebv_aBLUP = np.array(list(Pob_1.inds[i].ebv for i in range(Pob_1.n)))\nebv_aBLUP = pd.DataFrame(ebv_aBLUP)\n\ny_aBLUP = np.array(list(Pob_1.inds[i].y[itrait] for i in range(Pob_1.n)))\ny_aBLUP = pd.DataFrame(y_aBLUP)\n```\n:::\n\n\nA continuación podrá descargar los fenotipos observados y predichos usando el método BLUP.\n\n::: {.callout appearance=\"minimal\"}\n<i class=\"bi bi-download\"></i> [Fenotipos observados](datos/Fenotipo_0.csv){download=\"Fenotipo_0.csv\"}   [Fenotipos predichos](datos/ebv_0.csv){download=\"ebv_0.csv\"}\n:::\n\n::: codigo\nCon la función `sel.doEbv()` se obtiene el EVB (o fenotipo predicho) de acuerdo al método de predicción que se quiera implementar (aquí el BLUP), el cual se especifica en el argumento `criterion`. Luego, se crean dos objetos (ebv_aBLUP e y_aBLUP) donde se almacenan los EBV y los fenotipos observados (y).\n:::\n\n#### 5.2. Método ssGBLUP con densidad de SNP aproximada de 1.000\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmX_1 = gg.do_X([Pob_1.inds[i] for i in ind_gen], Gen_caracteristicas, Gen_Pob_base, chips[0], minMaf = 0.05)\n\nsel.doEbv(Pob_1, criterion = 'sstep', X = mX_1, yIds = ind_fen, mkrIds = ind_gen, h2 = 0.7, nh = Gen_caracteristicas.ploidy)\n\nebv_ssGBLUP = np.array(list(Pob_1.inds[i].ebv for i in range(Pob_1.n)))\nebv_ssGBLUP = pd.DataFrame(ebv_ssGBLUP_3)\n\ny_ssGBLUP = np.array(list(Pob_1.inds[i].y[itrait] for i in range(Pob_1.n)))\ny_ssGBLUP = pd.DataFrame(y_ssGBLUP)\n```\n:::\n\n\nA continuación podrá descargar los fenotipos observados y predichos usando el método ssGBLUP con densidad de 1.000.\n\n::: {.callout appearance=\"minimal\"}\n<i class=\"bi bi-download\"></i> [Fenotipos observados](datos/Fenotipo_1.csv){download=\"Fenotipo_1.csv\"}   [Fenotipos predichos](datos/ebv_1.csv){download=\"ebv_1.csv\"}\n:::\n\n::: codigo\nComo el método de predicción implementado es el ssGBLUP, inicialmente se recuperan los genotipos simulados usando la función `gg.do_X()`. Como en este caso la densidad del marcador estudiada es de 1.000, dentro de esta función se especifica esto por medio de la instrucción `chips[0]`. Luego, en el argumento `criterion` se especifica que el método de predicción a implementar corresponde al ssGBLUP. De igual forma, dentro de esta función se especifica también otros de los objetos anteriormente generados, como por ejemplo los genotipos (mX_1), los individuos fenotipados (ind_fen) y los individuos genotipados (ind_gen).\n:::\n\n#### 5.3. Método ssGBLUP con densidad de SNP aproximada de 10.000\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmX_2 = gg.do_X([Pob_1.inds[i] for i in ind_gen_1], Gen_caracteristicas, Gen_Pob_base, chips[1], minMaf = 0.05)\n\nsel.doEbv(Pob_1, criterion = 'sstep', X = mX_2, yIds = ind_fen, mkrIds = ind_gen, h2 = 0.7, nh = Gen_caracteristicas.ploidy)\n\nebv_ssGBLUP = np.array(list(Pob_1.inds[i].ebv for i in range(Pob_1.n)))\nebv_ssGBLUP = pd.DataFrame(ebv_ssGBLUP_3)\n\ny_ssGBLUP = np.array(list(Pob_1.inds[i].y[itrait] for i in range(Pob_1.n)))\ny_ssGBLUP = pd.DataFrame(y_ssGBLUP)\n```\n:::\n\n\nA continuación podrá descargar los fenotipos observados y predichos usando el método ssGBLUP con densidad de 10.000.\n\n::: {.callout appearance=\"minimal\"}\n<i class=\"bi bi-download\"></i> [Fenotipos observados](datos/Fenotipo_2.csv){download=\"Fenotipo_2.csv\"}   [Fenotipos predichos](datos/ebv_2.csv){download=\"ebv_2.csv\"}\n:::\n\n#### 5.4. Método ssGBLUP con densidad de SNP aproximada de 100.000\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmX_3 = gg.do_X([Pob_1.inds[i] for i in ind_gen_1], Gen_caracteristicas, Gen_Pob_base, chips[2], minMaf = 0.05)\n\nsel.doEbv(Pob_1, criterion = 'sstep', X = mX_3, yIds = ind_fen, mkrIds = ind_gen, h2 = 0.7, nh = Gen_caracteristicas.ploidy)\n\nebv_ssGBLUP = np.array(list(Pob_1.inds[i].ebv for i in range(Pob_1.n)))\nebv_ssGBLUP = pd.DataFrame(ebv_ssGBLUP_3)\n\ny_ssGBLUP = np.array(list(Pob_1.inds[i].y[itrait] for i in range(Pob_1.n)))\ny_ssGBLUP = pd.DataFrame(y_ssGBLUP)\n```\n:::\n\n\nA continuación podrá descargar los fenotipos observados y predichos usando el método ssGBLUP con densidad de 100.000.\n\n::: {.callout appearance=\"minimal\"}\n<i class=\"bi bi-download\"></i> [Fenotipos observados](datos/Fenotipo_3.csv){download=\"Fenotipo_3.csv\"}   [Fenotipos predichos](datos/ebv_3.csv){download=\"ebv_3.csv\"}\n:::\n\nPor último, se usó la correlación entre los valores fenotípicos observados y predichos como medida de predictibilidad, resultados que podrá observar a continuación.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Precisión de la predicción de acuerdo a los métodos BLUP y ssGBLUP (con diferentes densidad de marcadores).](seqbreed_files/figure-html/fig-pred-1.png){#fig-pred fig-align='center' width=74%}\n:::\n:::\n\n\n::: aclaracion\nEn los métodos de predicción, se suelen emplear dos tipos de conjuntos de muestra. La primera muestra se denomina muestra de referencia o de entrenamiento, mientras que la segunda es la muestra de validación o de individuos cuyo fenotipo se va a predecir. Aquí, se utilizaron dos muestras de prueba, los individuos de la generación $F_{2}$ y los individuos de la generación $F_{3}$, resultados que se presentan en la figura anterior (@fig-pred).\n:::\n\n### Referencia bibliográfica\n",
    "supporting": [
      "seqbreed_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}